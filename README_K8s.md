K8S
 
 1.自动化部署:yaml部署到k8s,会根据应用程序计算资源需求，自动分配到node.
 2.系统自愈:当成功部署到k8s中,node节点宕机,k8s会重新将pod调度到可用节点
 3.水平扩展:HPA周期调整RC的副本数量,将用户定义的resource的值匹配
 4.服务发现和负载均衡:内置服务发现功能,为每个容器分配IP,service代理
 5.自动更新和回滚:监控应用状态,不会同时杀掉应用,更新出错,自动恢复到原先状态
 
 
 
 Master节点和Node
 
 Master节点是集群控制节点，负责整个集群的管理和控制
 Api Server:提供接口,增删改查入口
 Controller Manager:所有资源对象的自动化控制中心
 Scheduler:负责资源调度
 Etcd:master的持续状态都存在etcd
 
 Node:Node工作节点,听从mater工作分配
 Kubelet:Pod容器创建，启停集群管理等任务
 kube-proxy:实现service的通信与负载均衡组件
 Dcoker:Docker引擎,负责本机容器创建和管理工作
 
 Rc是K8s集群中最早的保证Pod高可用的API对象。通过监控运行中的pod来保证
 集群中运行指定数目的Pod副本，指定数目可以是多个也可以是1个。少于指定
 数目Rc就会启动运行新的Pod副本;多于指定数目,Rc就会kill掉多余的Pod副本
 即使在指定数目为1的情况下，通过Rc运行Pod也比直接运行Pod更明智,因为Rc
 也可以发挥它高可用的能力,保证永远有1个Pod在运行。
 
  K8s  service资源对象
 一个Pod只是一个运行服务的实例,随时可能在一个节点上停止,在另一个节点以
 一个新的IP启动一个新的Pod,因此不能以确定的IP和端口号提供服务。
 要稳定地提供服务需要服务发现和负载能力。
 在K8s集群中,客户端需要访问的服务就是service对象,每个Service会对应一个集群
 内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务
 
  K8s  Deployment资源对象
  部署表示用户对K8s的一次更新操作可以是创建一个服务，更新一个服务，也可以是滚动
  升级一个服务，实际上是创建一个新的RS对象，然后逐渐将Rs里的的副本数增加到理想
  状态,将旧RS中的副本数减小到0的复合操作;这样一个复合操作用一个RS是不太好描述的
  所以用一个更通用的Deployment来描述。以K8S的发展方向,未来对所有长期伺服型的业务
  管理,都会通过Deployment来管理。
  
  Rs是新一代RC，提供同样的高可用能力,区别主要在于RS后来居上,能支持更多种类的匹配
  模式.副本及对象一般不单独使用,而是作为Deployment的理想状态参数使用
  
  DaemonSet
  作用:保证每个节点上都有一个pod
  
  job
  作用:job是k8s用来控制批处理型任务的API对象
  
  master 组件
  Api Server：对外暴露K8S的api接口，是外界进行资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；
  scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；就是监视新创建的 Pod，如果没有分配节点，就选择一个节点供他们运行，这就是pod的调度
  controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等，它们是处理集群中常规任务的后台线程
  etcd：kubernetes的后端数据库，k/v方式存储，所有的k8s集群数据都存放在此处。保存了整个集群的状态
  其中有kube-scheduler和kube-controller-manager两个组件是有leader选举的，这个选举机制是k8s对于这两个组件的高可用保障。
  apiserver是可以水平扩展的
 
